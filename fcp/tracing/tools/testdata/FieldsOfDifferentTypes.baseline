============== FieldsOfDifferentTypes.fbs ============
include "${DIR}/tracing_schema_common.fbs";

table IntegersOnly (tag: "TTT0") {
  field1: int32;
  field2: int32;
}

table IntegersWithString (tag: "TTT1") {
  field1: int32;
  field2: string;
}

============== diagnosis ============

============== result ============
// Autogenerated by tracing_traits_generator, do not edit

#ifndef THIRD_PARTY_FCP_TRACING_TOOLS_TESTDATA_FIELDSOFDIFFERENTTYPES_H
#define THIRD_PARTY_FCP_TRACING_TOOLS_TESTDATA_FIELDSOFDIFFERENTTYPES_H

#ifdef FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_
#undef FLATBUFFERS_GENERATED_TRACINGSCHEMA_H_
#endif
#include "${DIR}/tools/testdata/FieldsOfDifferentTypes_generated.h"
#include "absl/strings/string_view.h"
#include "${DIR}/tracing_severity.h"
#include "${DIR}/tracing_traits.h"
#include "flatbuffers/minireflect.h"
#include "flatbuffers/idl.h"
#include "${BASE}/platform.h"

namespace fcp {

template<> class TracingTraits<IntegersOnly>: public TracingTraitsBase {
 public:
  static constexpr TracingTag kTag = TracingTag("TTT0");
  static constexpr TracingSeverity kSeverity = fcp::TracingSeverity::kInfo;
  static constexpr bool kIsSpan = false;
  const char* Name() const override { return "IntegersOnly"; }
  TracingSeverity Severity() const override {
    return fcp::TracingSeverity::kInfo;
  }
  std::string TextFormat(const flatbuffers::DetachedBuffer& buf) const override {
    return flatbuffers::FlatBufferToString(buf.data(), IntegersOnlyTypeTable());
  }
  std::string JsonStringFormat(const uint8_t* flatbuf_bytes) const override {
    flatbuffers::Parser parser;
    std::string schema_file;
    std::string fbs_file = "${RUNFILE_PATH}/tools/testdata/FieldsOfDifferentTypes.fbs";
    flatbuffers::LoadFile(GetDataPath(fbs_file).c_str(), true, &schema_file);
    std::string schema_path_common = GetDataPath("${DIR}/tracing_schema_common.fbs");
    std::string directory_common = schema_path_common.substr(0, schema_path_common.find("${DIR}/tracing_schema_common.fbs"));
    const char *include_directories[] = {
                 directory_common.c_str(), nullptr};
    parser.Parse(schema_file.c_str(), include_directories);
    std::string jsongen;
    parser.SetRootType("IntegersOnly");
    GenText(parser, flatbuf_bytes, &jsongen);
    return jsongen;
  }
  static flatbuffers::Offset<IntegersOnly> Create(std::int32_t field1, std::int32_t field2, flatbuffers::FlatBufferBuilder* fbb) {
    return CreateIntegersOnly(*fbb, field1, field2);
  }
  using TupleType = std::tuple<std::int32_t, std::int32_t>;
  static TupleType MakeTuple(const IntegersOnly* table) {
    return std::make_tuple(table->field1(), table->field2());
  }
};
static internal::TracingTraitsRegistrar<IntegersOnly> registrar_IntegersOnly;
template<> class TracingTraits<IntegersWithString>: public TracingTraitsBase {
 public:
  static constexpr TracingTag kTag = TracingTag("TTT1");
  static constexpr TracingSeverity kSeverity = fcp::TracingSeverity::kInfo;
  static constexpr bool kIsSpan = false;
  const char* Name() const override { return "IntegersWithString"; }
  TracingSeverity Severity() const override {
    return fcp::TracingSeverity::kInfo;
  }
  std::string TextFormat(const flatbuffers::DetachedBuffer& buf) const override {
    return flatbuffers::FlatBufferToString(buf.data(), IntegersWithStringTypeTable());
  }
  std::string JsonStringFormat(const uint8_t* flatbuf_bytes) const override {
    flatbuffers::Parser parser;
    std::string schema_file;
    std::string fbs_file = "${RUNFILE_PATH}/tools/testdata/FieldsOfDifferentTypes.fbs";
    flatbuffers::LoadFile(GetDataPath(fbs_file).c_str(), true, &schema_file);
    std::string schema_path_common = GetDataPath("${DIR}/tracing_schema_common.fbs");
    std::string directory_common = schema_path_common.substr(0, schema_path_common.find("${DIR}/tracing_schema_common.fbs"));
    const char *include_directories[] = {
                 directory_common.c_str(), nullptr};
    parser.Parse(schema_file.c_str(), include_directories);
    std::string jsongen;
    parser.SetRootType("IntegersWithString");
    GenText(parser, flatbuf_bytes, &jsongen);
    return jsongen;
  }
  static flatbuffers::Offset<IntegersWithString> Create(std::int32_t field1, absl::string_view field2, flatbuffers::FlatBufferBuilder* fbb) {
    auto field2__ = fbb->CreateString(field2.data(), field2.size());
    return CreateIntegersWithString(*fbb, field1, field2__);
  }
  using TupleType = std::tuple<std::int32_t, std::string>;
  static TupleType MakeTuple(const IntegersWithString* table) {
    return std::make_tuple(table->field1(), table->field2()->str());
  }
};
static internal::TracingTraitsRegistrar<IntegersWithString> registrar_IntegersWithString;
} // namespace fcp

#endif  // THIRD_PARTY_FCP_TRACING_TOOLS_TESTDATA_FIELDSOFDIFFERENTTYPES_H

